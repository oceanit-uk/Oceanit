<!doctype html>
<html lang="en-GB">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebGL Galaxy — Scroll to Fly</title>
<style>
  html,body { height:100%; margin:0; background:#02020a; color:#fff; font-family: Inter, system-ui, sans-serif; }
  /* Canvas fills screen */
  #canvas-wrap { position:fixed; inset:0; z-index:0; pointer-events:none; }
  canvas { display:block; width:100vw; height:100vh; }

  /* UI / content goes above the WebGL canvas */
  .hero {
    position:relative;
    z-index:3;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }

  .hero h1 {
    font-size:clamp(28px,6vw,64px);
    margin:0;
    text-align:center;
    color: #e6f3ff;
    text-shadow: 0 6px 30px rgba(0,120,255,0.12), 0 1px 1px rgba(0,0,0,0.6);
  }

  .section {
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:3;
    position:relative;
    pointer-events:auto;
  }

  .caption {
    color:#cfecff;
    max-width:900px;
    text-align:center;
    padding:0 20px;
    line-height:1.5;
  }

  /* When WebGL is not available */
  #no-webgl {
    position:fixed;
    z-index:5;
    left:20px;
    top:20px;
    background:rgba(0,0,0,0.6);
    padding:10px 14px;
    border-radius:8px;
    display:none;
    color:#ffdcdc;
    font-size:14px;
  }
</style>
</head>
<body>

<div id="canvas-wrap"><canvas id="glCanvas"></canvas></div>

<div id="no-webgl">WebGL is not supported or blocked. Try opening this page via <code>http://localhost/</code> in a modern browser (Chrome, Firefox, Edge).</div>

<!-- Content sections (so page has scroll) -->
<section class="hero">
  <h1>Fly through the galaxy — scroll down</h1>
</section>

<section class="section">
  <div class="caption">
    <h2 style="margin-top:0;color:#bfe7ff">Experience a procedural galaxy</h2>
    <p>This background is rendered with WebGL (Three.js). Scrolling moves the camera forward so you appear to fly through the stars and cosmic dust. Use on any PHP/HTML page — drop the canvas and script into your template. For best results run via a local or production server (not file://).</p>
  </div>
</section>

<section class="section" style="background:linear-gradient(180deg,#02020a 0%, #030319 100%);">
  <div class="caption">
    <h3 style="margin-top:0;color:#bfe7ff">Tweak & customize</h3>
    <p>Change star count, colors, dust intensity, or map the scroll to different speed ranges. Read the comments inside the script for quick parameters.</p>
  </div>
</section>

<!-- Three.js from unpkg — should work for most setups -->
<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

<script>
/*
  WebGL Galaxy with scroll-driven camera movement
  - Paste this into any PHP/HTML page
  - Recommended: open via server (http://localhost/...)
  - Adjust parameters in the "CONFIG" block below
*/

// Quick WebGL support check
if (!window.WebGLRenderingContext) {
  document.getElementById('no-webgl').style.display = 'block';
  throw new Error('WebGL not supported');
}

const canvas = document.getElementById('glCanvas');
const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x02020a, 1);

// Scene & Camera
const scene = new THREE.Scene();

// Use a perspective camera -- field of view gives 'space feel'
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
// We'll place camera near origin and move it forward along negative z as we scroll.
camera.position.set(0, 0, 10);

// Lighting (subtle rim/ambient to give depth)
const ambient = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambient);
const rim = new THREE.DirectionalLight(0xfff6f0, 0.6);
rim.position.set(-1, 0.5, 1).normalize();
scene.add(rim);

/* =========================
   CONFIG — tweak these
   ========================= */
const CONFIG = {
  STAR_COUNT: 7000,         // number of small bright stars
  DUST_COUNT: 1200,         // number of big faint particles (dust / nebula)
  GALAXY_RADIUS: 1400,      // radius of spread
  CAMERA_SCROLL_Z: -1200,   // total camera travel on scroll (negative moves forward)
  STAR_SIZE: 0.9,           // base size of stars
  DUST_SIZE: 20.0,          // base size of dust sprites
  ROTATION_SPEED: 0.02      // slow rotation of the galaxy
};

/* =========================
   Helper: make a soft circular sprite texture from canvas
   returns THREE.Texture
   ========================= */
function createStarSprite(colorHex = '#ffffff', size = 64) {
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');

  // radial gradient for soft glow
  const grd = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
  grd.addColorStop(0, colorHex);
  grd.addColorStop(0.3, colorHex);
  grd.addColorStop(0.6, 'rgba(255,255,255,0.15)');
  grd.addColorStop(1, 'rgba(255,255,255,0)');

  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, size, size);

  const tex = new THREE.Texture(c);
  tex.needsUpdate = true;
  return tex;
}

/* =========================
   Create stars (Points)
   ========================= */
const starGeometry = new THREE.BufferGeometry();
const starPositions = new Float32Array(CONFIG.STAR_COUNT * 3);
const starColors = new Float32Array(CONFIG.STAR_COUNT * 3);
const starSizes = new Float32Array(CONFIG.STAR_COUNT);

for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
  // spherical / disk distribution with bias toward center for galaxy-like look
  const radius = Math.pow(Math.random(), 0.6) * CONFIG.GALAXY_RADIUS;
  const theta = Math.random() * Math.PI * 2;
  const phi = (Math.random() - 0.5) * 0.6; // keep fairly flat -> galactic plane

  const x = Math.cos(theta) * radius;
  const y = Math.sin(phi) * (radius * 0.25); // less vertical spread
  const z = Math.sin(theta) * radius;

  const i3 = i * 3;
  starPositions[i3 + 0] = x;
  starPositions[i3 + 1] = y;
  starPositions[i3 + 2] = z;

  // subtle color variance: bluish-white to warm-white
  const hue = 0.6 + (Math.random() * 0.15); // bluish tint
  const saturation = 0.8;
  const lightness = 0.9 - Math.random()*0.4;

  // convert HSL -> RGB (quick)
  const color = new THREE.Color();
  color.setHSL(hue, saturation, lightness);
  starColors[i3 + 0] = color.r;
  starColors[i3 + 1] = color.g;
  starColors[i3 + 2] = color.b;

  starSizes[i] = CONFIG.STAR_SIZE * (0.5 + Math.random()*1.8);
}

starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

// PointsMaterial with sprite texture
const starSprite = createStarSprite('#ffffff', 128);
const starMaterial = new THREE.PointsMaterial({
  size: CONFIG.STAR_SIZE,
  map: starSprite,
  vertexColors: true,
  transparent: true,
  opacity: 0.95,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  sizeAttenuation: true
});

const stars = new THREE.Points(starGeometry, starMaterial);
scene.add(stars);

/* =========================
   Dust / Nebula particles
   larger, softer points
   ========================= */
const dustGeometry = new THREE.BufferGeometry();
const dustPositions = new Float32Array(CONFIG.DUST_COUNT * 3);
const dustColors = new Float32Array(CONFIG.DUST_COUNT * 3);
const dustSizes = new Float32Array(CONFIG.DUST_COUNT);

for (let i = 0; i < CONFIG.DUST_COUNT; i++) {
  const radius = Math.pow(Math.random(), 0.8) * (CONFIG.GALAXY_RADIUS * 0.9);
  const theta = Math.random() * Math.PI * 2;
  const phi = (Math.random() - 0.5) * 1.5;

  const x = Math.cos(theta) * radius;
  const y = Math.sin(phi) * (radius * 0.6);
  const z = Math.sin(theta) * radius;

  const idx = i * 3;
  dustPositions[idx + 0] = x;
  dustPositions[idx + 1] = y;
  dustPositions[idx + 2] = z;

  const color = new THREE.Color(0x3fb0ff);
  color.offsetHSL((Math.random()-0.5)*0.05, 0.1, (Math.random()-0.5)*0.05);
  dustColors[idx + 0] = color.r;
  dustColors[idx + 1] = color.g;
  dustColors[idx + 2] = color.b;

  dustSizes[i] = CONFIG.DUST_SIZE * (0.6 + Math.random() * 1.6);
}

dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
dustGeometry.setAttribute('color', new THREE.BufferAttribute(dustColors, 3));
dustGeometry.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));

// Dust sprite (soft bluish)
const dustSprite = createStarSprite('#60c8ff', 256);
const dustMaterial = new THREE.PointsMaterial({
  size: CONFIG.DUST_SIZE,
  map: dustSprite,
  vertexColors: true,
  transparent: true,
  opacity: 0.22,
  blending
